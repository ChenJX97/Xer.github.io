# JVM运行时数据区域

## 线程共享

#### Java堆 (Java Heap)

堆中存放**实例对象**和**数组**，是**垃圾收集器管理**的主要区域；

- 在**分代收集算法**下，堆空间又可分为 **新生区**(1/3) 和 **老年区**(2/3)；

​		新生区又可分为 **Eden**(8/10)，**From Survivor**(1/10)，**To Survivor**(1/10)；

​	在内存分配角度，堆可划分出多个线程私有的**分配缓冲区**（**TLAB**，Thread Local Allocation Buffer）；

​	堆中可能导致异常类型：OOM（**OutOfMemoryError**）；

#### 方法区(Method Area)

​	方法区中存放已被虚拟机加载的**类信息、常量、静态变量、即时编译器所生成的代码**；

- ##### **运行时常量池 Runtime Constant Pool**

​		1. 字节码文件中有一个常量池表，存放了编译期生成的**字面量**和**符号引用**；

​		2.  在字节码被加载进虚拟机后，该常量池表的内容就进入了方法区的运行时常量池中；

​		3. 不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中(String的intern())；

​		4. 在Hotspot虚拟机中，GC分代收集扩展至方法区，所以很多人又将方法区称为永久代；

​	方法区的回收：主要是**常量池的回收**和**类型的卸载**；

​	方法区中可能导致异常类型：OOM（**OutOfMemoryError**）

#### 直接内存(Direct Memory)

​	直接内存是虚拟机以外的内存区域，由操作系统所管理；

- **NIO（JDK1.4）**

  ​	1. 基于通道**Channel**和缓冲区**Buffer**的I/O方式；

  ​	2. 使用Native函数库**直接分配堆外内存**；

  ​	3. 通过堆中的DirectByteBuffer对象作为这块内存的引用；

  ​	4. 避免了在Java堆和Native堆中来回复制数据；

  

## 线程私有

#### PC寄存器(Program Counter Register)

​	PC寄存器是当前线程所执行的字节码的**行号指示器；**

- **作用**

  ​	1. 改变这个计数器的值来选取下一条需要执行的字节码指令；

  ​	2. 在线程切换时，可恢复上次的执行位置；

  执行的是Java方法时，计数器记录的是正在执行的虚拟机字节码指令的地址；

  执行的是Native方法时，计数器的值为空

  PC寄存器也是**唯一不会OOM**的区域

#### Java虚拟机栈(Java Virtual Machine Stacks)

​	虚拟机栈描述的是Java方法执行的**内存模型；**

​	每个方法在执行时都会创建一个**栈帧**，每一个方法从**调用**到**执行完成**的过程，对应着一个栈帧在虚拟机栈**入栈**到**出栈**的过程；

​	栈帧由 **局部变量表**，**操作数栈**，**动态链接**，**方法出口** 所组成；

- 局部变量表

  ​	1. 存放基本数据类型，引用类型，returnAddress类型；

  ​	2. long，double类型占两个局部变量空间；

  ​	3. **局部变量表所需的内存空间在编译期间完成分配；**

  虚拟机栈可能出现的异常：**StackOverflowError**，**OutOfMemoryError**

#### 本地方法栈(Native Method Stack)

​	虚拟机调用Java方法使用的是虚拟机栈，而调用Native方法使用的是本地方法栈