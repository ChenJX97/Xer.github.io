---
layout: post
title: JAVA：JVM内存结构
categories:
  - JAVA
tags:
  - Java
---

## 1.概述
JAVA代码需在JVM（JAVA虚拟机）上运行，JVM在执行JAVA程序的过程中会把所管理的内存划分为若干个不同的区域：**堆**（Heap）、**方法区**（Method Area）、**PC寄存器**（The pc Register）、**虚拟机栈**（Virtual Machine Stacks）和**本地方法栈**（Native Method Stacks）。

其中​​**堆和方法区**是所有**线程共有**的区域；其余是**线程私有**的区域。
![](https://i.imgur.com/wSTq3iX.jpg)
## 2.堆内存（Heap Memory）
 堆（Heap），也叫JAVA堆，是JVM管理的最大内存区域，在**JVM启动时创建**，是**所有线程共享**的。

 该内存区域主要存放**对象实例（及其值）和数组**。

 堆内存容量的最小值和最大值可分别通过`-Xms`和`-Xmx`进行参数设置，当JVM中空余堆内存小于40%（可通过"`-XX:MinHeapFreeRation=`"修改该比例）时，堆内存容量会增大到最大值，当空余堆内存大于70%（可通过"`-XX:MaxHeapFreeRation=`"修改该比例）时，堆内存容量将缩小至最小值。对于运行系统，一般将堆内存的最小值和最大值设置为一样大小。

![](https://i.imgur.com/fGz141v.png)

 根据分代收集算法，堆可划分成**新生代**和**老年代**​。

### 2.1 新生代（Young Generation） 
 用于分配内存给程序所**创建的新对象**，可通过`-Xmn`参数设置新生代的大小。新生代可划分成**一个​Eden Space和两个相同大小的Survivor Space。**

### • Eden Space
存放**新生的对象**，可通过`-XX:SurvivorRation`来调整大小。
### • 两个Survivor Space 
又被称作S0、S1或From Space、To Space，存放**每次垃圾回收后所存活的对象**，可通过`-XX:SurvivorRation`来调整大小。
### 2.2 老年代（Old Generation） 
存放新生代中经过**多次GC（垃圾回收）后存活下来的对象**。两种情况下新对象可能直接进入老年代：大对象、大而且无引用外部对象的数组对象。
> 老年代内存 = 堆最大值（-Xmx）- 新生代大小（-Xmn）。

## 3.非堆内存（Non-heap Memory）
顾名思义，非堆内存（Non-heap Memory）是JVM运行内存中堆以外的内存。这些内存直接受操作系统管理（而不是JVM），减少垃圾回收对应用程序造成的影响。

非堆内存由​**方法区**（Method Area）、**PC寄存器**（The pc Register）、**虚拟机栈**（Virtual Machine Stacks）和**本地方法栈**（Native Method Stacks）组成。
### 3.1 方法区（Method Area） 
方法区又称“永久代”，用于**存储对象的类型信息**（类信息、常量、静态常量、方法、方法字段）和即时编译器编译产生的代码数据。方法区所**分配的内存可不连续，允许动态扩展，是所有线程共享的**。

​大小：默认最小值为16MB，最大值为64MB，可通过`-XX:PermSize`和`-XX:MaxPermSize`参数设置方法区的大小。

其内存**回收效率比堆内存低**。

无法满足内存需求时，会抛出**OutOfMemoryError**异常
### • 运行时常量池（Run-Time Constant Pool） 
运行时常量池是方法区的一部分，主要存储**类（Class）文件常量池**中的**符号引用及其直接引用**和程序运行时通过**代码所产生的常量**，也是**所有线程共享的**。

同方法区一样，无法申请到新的内存时，将抛出**OutOfMemoryError**异常​。
### 3.2 虚拟机栈（Virtual Machine Stacks） 
虚拟机栈，是JAVA方法执行的内存区域，用来存储局部变量和方法调用。当一个**方法被调用时会创建一个栈帧**，栈帧存放着方法中的信息，然后将栈帧压入虚拟机栈。每个方法被**调用到执行完**的过程，就对应着一个栈帧在虚拟机栈中从**入栈到出栈**的过程。​

栈内存是**线程私有**的。
### • 栈帧 
栈帧由三部分组成：**局部变量区**、**操作数栈**、**帧数据区**。根据所调用方法的类型信息分配局部变量区和操作数栈的大小。
####  局部变量区
其本质为一个**从0开始计数的数组，每个数组元素大小为一个字长**。short、byte和char类型的值存入数组前要转换成int类型，long和double类型的值在数组中要占两个元素的长度（两个字长）。**通过索引进行取值**，两个字长的值只需索引首个字长的索引值。如某个long值在局部变量区中占据的索引时3、4项，取值时，指令只需取索引为3的long值即可。

​其大小在编译期间完成分配。

**注意**：并不是所有基本类型都存储在栈中，基本类型所定义的数组对象存放在​堆内存中。
#### 操作数栈
其本质为一个以**一个字长为单位的栈**，通过入栈、出栈的方式进行访问数据。操作数栈是在存储计算时的一个**临时数据存储区域**。
#### 帧数据区
其用来存放支持**常量池解析**、**正常方法返回**以及**异常派发机制**的数据。
### • 堆和栈的区别
#### 功能不同
栈内存用来存储局部变量和方法调用。
​堆内存用来存放对象实例（及其值）和数组。
#### 共享性不同
栈内存是线程私有的。
堆内存是所有线程共有的。
#### 异常错误不同
栈空间不足：java.lang.StackOverFlowError。
堆空间不足：java.lang.OutOfMemoryError。
#### 空间大小
栈的空间大小远远小于堆的。
### 3.3 本地方法栈（Native Method Stacks）
 本地方法栈与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的JAVA方法服务，而本地方法栈则是为Native方法服务。
### 3.4 PC寄存器（The pc Register）
PC寄存器是JVM内存结构中最小的一块内存区域，本质是一个**指示器**，指向当前线程所执行的字节码的行号，可通过改变该寄存器的值来选取下一条需要执行的字节码指令。
 
PC寄存器可用来实现**​分支、循环、异常处理、线程恢复**等基础功能。
## 4.总结 
![](https://i.imgur.com/GzoxIC7.png)
## 5.参考资料 

["Java虚拟机的内存组成以及堆内存介绍-HollisChuang's Blog"](http://www.hollischuang.com/archives/80)

[Java堆和栈看这篇就够 - Johnny-Zhuang's Technology Blog](https://iamjohnnyzhuang.github.io/java/2016/07/12/Java%E5%A0%86%E5%92%8C%E6%A0%88%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F.html)

[Java虚拟机的堆、栈、堆栈如何去理解？ - 知乎](https://www.zhihu.com/question/29833675)

[Java 内存之方法区和运行时常量池 - 漠然的博客mritd Blog](https://mritd.me/2016/03/22/Java-%E5%86%85%E5%AD%98%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0/)

[从0到1起步-跟我进入堆外内存的奇妙世界 - 简书](https://www.jianshu.com/p/50be08b54bee)​​